=== Fernbedienung ===

Kein VDR wäre komplett ohne die Möglichkeit ihn bequem per Fernbedienung zu steuern.
{version} unterstützt ein breites Spektrum von Eingabegeräten, sowohl Infrarot- als auch Funk-Fernbedienungen.

////
Ob deine Fernbedienung unterstützt wird, kannst du 
****
hoffentlich bald hier lesen - Liste im yaVDR-Wiki sinnvoll?
****
////

[TIP]
.Das yaVDR-Projekt lebt von deiner Mithilfe.
=====================================================================================
Bitte schicke den Entwicklern die Konfigurationsdateien für deine noch nicht OOTB footnote:[Out of the box, d.h. direkt nach der Installation von yaVDR funktionierend] funktionsfähige Fernbedienung,
damit die Hardware-Unterstützung für die kommenden Versionen verbessert werden kann.
======================================================================================

[[eventlirc]]
==== Eventlircd ====

{version} benutzt standardmäßig eventlircd, ein Dienst der dabei hilft die unterschiedlichen Treiber und Eingabegeräte unter einen Hut zu bringen. Es dient sozusagen als Filter, der die Tastendrücke aller konfigurierten Fernbedienungen auswertet, auf Wunsch die Tastencodes vereinheitlicht und an den VDR weiterreicht.

===== Grundlagen footnote:[http://www.vdr-portal.de/board60-linux/board14-betriebssystem/board96-yavdr/p1009867-yavdr-0-4-eventlircd-und-fernbedienungen-die-grundlagen/#post1009867] =====

http://code.google.com/p/eventlircd[*Eventlircd*] übersetzt Tastendrücke von Kernel Input Devices footnote:[bzw. Eingabegeräte, für die durch den Treiber ein Eintrag unter '/dev/input/' erstellt wird] in Lirc-Tastendrücke. Im Prinzip ähnelt die Funktion dem remote-plugin mit dem Unterschied, dass zuvor den Tasten über eine evmap footnote:[Konfigurationsdatei, die für die Übersetzung des Tastendrucks auf der Fernbedienung in eine Taste am Computer herangezogen wird] eine andere Funktion zugewiesen werden kann.

Solche Eingabegeräte sind zum Beispiel normale Tastaturen oder auch Fernbedienungen die über ihre Treiber als Tastaturen eingebunden werden. Fernbedienungen welche an DVB Karten angeschlossen sind, melden sich teilweise ebenfalls als Tastaturen, außerdem existiert eine neue Schnittstelle für Fernbedienungen namens rc-core, auf welche Jarod Wilson footnote:[Neuer Maintainer des Lirc Projektes] schon einige der bestehenden Lirc Treiber und auch einige Konfigurationen der mit DVB Geräten ausgelieferten Fernbedienungen portiert hat.
Auch diese Schnittstelle - auch wenn sie kein normaler Tastaturtreiber ist - stellt ihre Geräte als Eingabegeräte zur Verfügung.

Eingaben von Zeigegeräten (wie Maus, Touchpad, Grafiktablett), die ebenfalls über die Input-Schnittstelle arbeiten, versucht eventlircd unverändert durchzuleiten (es sei denn sie werden über eine evmap auf ein Key-Event umgemappt.

Eventlircd erkennt Eingabegeräte über ein <<udev,udev>>-Attribut, auch wenn sie erst nach dem Start des Dämon eingebunden oder angeschlossen werden. Hier liegt einer der Vorteile dieser Lösung, da eventlircd ab seinem Start einen Lirc Socket für den VDR bereitstellt, und nach und nach die ihm zugeordneten Geräte als Eingabegeräte einbinden kann. 

Um welche Geräte es sich kümmern soll, erkennt eventlircd anhand von Attributen, welche man den Geräten bei der Initialisierung über <<udev-rules,udev-Regeln>> mitgeben kann. Für manche Geräte funktioniert das schon in der Standardkonfiguration (rc-core, Eingabegeräte die das yaVDR-Team selber besitzt, Konfigurationen die an das yaVDR-Team weitergegeben wurden). 
Die Ausgabe erfolgt nach Verarbeitung durch Eventlircd für die Anwendungen dann so, als würde sie von einem einzigen Gerät stammen.

Da manche Geräte eindeutig erkannt werden können (zum Beispiel USB Geräte), kann man diese über <<udev-rules,udev-Regeln>> mit der für das jeweilige Geräte richtigen Konfiguration automatisch einbinden. Die Konfigurationen für all diese Geräte kann man alle gleichzeitig auf dem System haben, da durch udev nur die Konfiguration für angeschlossene Geräte aktiviert wird.

Eventlircd kann geräte- oder treiberabhängig eine Übersetzungstabelle mitgegeben werden, um die Tastenbelegung anzupassen. (sogenannte <<evmaps,evmaps>>)

Lircd footnote:[Der LIRC-Daemon] kann man über den Switch footnote:[Das Startargument] --uinput footnote:[User Level Input Subsystem - eine Schnittstelle, um Eingaben aus dem Userland an den Kernel zu übermitteln] anweisen seine Tastendrücke an ein Gerät unter '/dev/input/'  zu übergeben. Damit kann dann lircd parallel zu anderen Eingabegeräten gestartet werden und es ist so theoretisch auch möglich mehrere Instanzen von lircd für verschiedene Geräte mit unterschiedlicher Konfiguration gleichzeitig starten. Für USB-Lirc Empfänger wird über eine udev-Regel in '/lib/udev/rules.d/98-lircd.rules' und dem lircd_helper eine Instanz des Lirc-Daemon gestartet und die in der udev-Regel angegebenen Treiber und lircd.conf benutzt. Für diese Empfänger ist keine Konfiguration über das Webfrontend erforderlich. Weitere noch nicht OOTB unterstützte Lirc-Empfänger sollten entsprechend über ergänzende  udev-Regeln nachgepflegt werden.

[NOTE]
.Bug bei Verwendung von --uinput
=====================================================================
Leider scheinen aktuelle Lirc-Versionen unter einem Bug bei der Übergabe von Tastendrücken bei Verwendung von *--uinput* zu leiden - es kommen dann doppelte Tastendrücke am Eventgerät an (die Tastendrücke an eigentlichen Lircd-Socket hingegen sind in Ordnung). Daher wird in {version} lircd2uinput verwendet, um Tastendrücke von Lirc-Sockeln an eventlircd weiterzureichen.
=====================================================================


[TIP]
.Alle Wege führen zu Eventlircd
=====================================================================
image:EventlircdOrganigrammconfigfilesyaVDR0.5.png["Übersicht der Eventlircd",align="center"]

Je nachdem welchen Anschluss und welche Treiber die eigenen Empfänger bzw. TV-Karten verwenden kann der Weg eines Tastendrucks also sehr unterschiedlich sein, bis er von eventlircd ausgewertet wird. Dieses Hintergrundwissen ist dann von Vorteil, wenn die Tastenbelegung, die Eventlircd ausgibt nicht zur *remote.conf* von yaVDR passt.
=====================================================================

////
****
[qanda]
Ich: Gibt es TV-Karten, die direkt ein event-Gerät unter /dev/input/ anlegen ohne rc-core zu benutzen?::
steffenbpunkt: Ja gibt es
das war die vorgehensweise vor rc-core
das ganze ist ja noch sehr neu
das heisst nur neuere DVB Treiber benutzen rc-core
****
////

<<<<

.Die Vorteile sind also:
* frühe Verfügbarkeit des Lircsocket (und damit schnellerer Start des VDR)
* Vorkonfiguration für verschiedenste Eingabegeräte möglich
* Tastatur- , rc-core- und Lirc-Geräte können angesprochen werden.
* Die Konfiguration durch den Nutzer entfällt, wenn die Fernbedieung und der Empfänger den yaVDR-Entwicklern bereits bekannt sind und schon unterstützt werden.

.Wie bei jedem anderen Konzept gibt es natürlich auch "Nachteile": 
* Um die Vorteile der Lösung mit Eventlircd zu nutzen, braucht man eine Standardbelegung auf die man die Tasten normalisieren kann, dadurch kommt dann die Anlernfunktion des VDR nicht mehr zum tragen. Wenn das Gerät noch nicht unterstützt wird, bedeutet dies unter Umständen ein etwas mühsames manuelles Anpassen bis die Tasten der eigenen Fernbedienung auf die yaVDR-Team mitgelieferte Belegung für Lirc in der '/var/lib/vdr/remote.conf' passt. 
* Um in den Genuß zu kommen Lirc wie oben beschrieben nutzen zu können, müssen die Tasten in der lircd.conf entsprechend der Regeln der Inputgeräte benannt werden. Bei Lirc heisst das Namespace-konform benannt sein. Sinnvoll wäre hier natürlich eine Benennung entsprechend unserer Standardbelegung. 

Bei der yaVDR-Standardbelegung haben sich die Entwickler an der http://www.linuxtv.org/wiki/index.php/Remote_Controllers[Dokumentation von linux-media] (Tabelle am Ende der Seite) orientiert und benutzen diese als Referenz, eine Zuordnung von VDR-Taste und Tastenname kann man sich hier ansehen: https://bugs.yavdr.com/projects/1/wiki/IR_Integration_04#Eventmapping[neue IR-Integration für yaVDR 0.4]

[[remote.conf]]
==== remote.conf ====

[[namespace]]
[CAUTION]
.Vorsicht bei Änderungen für die Fernbedienung an der remote.conf!
=====================================================================
yaVDR ist auf eine standardisierte remote.conf für den VDR und eine dazu passende Lircmap.xml für XBMC ausgelegt, damit die Fernbedienung sowohl im VDR als auch unter XBMC richtig funktioniert. Das hat zur Folge, dass die Tastennamen in den Lirc-Konfigurationsdateien, den Keytables von ir-core und den von Eventlircd direkt angesprochenen Geräten <<namespace-faq, *Namespace-konform* zur input.h des Kernels>> sein *müssen* (sonst kann sie eventlircd nicht weiterreichen) und möglichst passend zur remote.conf eingestellt werden sollten.
Die Anpassung des Mappings ist in diesem Kapitel beschrieben.
=====================================================================

Die remote.conf liegt unter /var/lib/vdr/remote.conf und ist eine <<template, getemplatete>> Datei. Sie sollte möglichst nicht verändert werden (Ausnahme ist die Konfiguration der Tastenbelegung für Tastaturen und ggf. Sondertasten der Fernbedienung), und gibt vor wie die von den Fernbedienungen gelieferten Tastennamen lauten sollten. Die Benennung ist gleichzeitig auf die XBMC-Konfiguration abgestimmt, so dass auch XBMC ohne weitere Anpassung seiner Keymaps bedienbar sein sollte.

Die Zuordnung von Funktion im VDR und Tastennamen sieht bei {version} so aus:

.Namespace-konforme Tastennamen in {version}
[cols="2s,2s,4e",options="header"]
|=========================================
|*remote.conf*     |*Tastenname durch Eventlircd*|*Beschreibung*
|LIRC.Up 	|KEY_UP 	|Nach oben
|LIRC.Down 	|KEY_DOWN 	|Nach unten
|LIRC.Menu 	|KEY_MENU 	|Menü
|LIRC.Ok 	|KEY_OK 	|OK/Eingabe
|LIRC.Back 	|KEY_ESC 	|Zurück
|LIRC.Left 	|KEY_LEFT 	|Nach links
|LIRC.Right 	|KEY_RIGHT 	|Nach rechts
|LIRC.Red 	|KEY_RED 	|Rot
|LIRC.Green 	|KEY_GREEN 	|Grün
|LIRC.Yellow 	|KEY_YELLOW 	|Gelb
|LIRC.Blue 	|KEY_BLUE 	|Blau
|LIRC.0 	|KEY_0 	|Ziffer 0
|LIRC.1 	|KEY_1 	|Ziffer 1
|LIRC.2 	|KEY_2 	|Ziffer 2
|LIRC.3 	|KEY_3 	|Ziffer 3
|LIRC.4 	|KEY_4 	|Ziffer 4
|LIRC.5 	|KEY_5 	|Ziffer 5
|LIRC.6 	|KEY_6 	|Ziffer 6
|LIRC.7 	|KEY_7 	|Ziffer 7
|LIRC.8 	|KEY_8 	|Ziffer 8
|LIRC.9 	|KEY_9 	|Ziffer 9
|LIRC.Info 	|KEY_INFO 	|Info zum aktuellen Objekt
|LIRC.Play 	|KEY_PLAY 	|Play
|LIRC.Pause |KEY_PAUSE 	|Pause
|LIRC.Stop 	|KEY_STOP 	|Stop
|LIRC.Record 	|KEY_RECORD 	|Aufnehmen
|LIRC.FastFwd 	|KEY_FASTFORWARD 	|Vorspulen
|LIRC.FastRew 	|KEY_REWIND 	|Zurückspulen
|LIRC.Next 	|KEY_NEXT 	|Vorwärts springen
|LIRC.Prev 	|KEY_BACK 	|Rückwärts springen
|LIRC.Power 	|KEY_POWER2 	|Ausschalten
|LIRC.Channel+ 	|KEY_CHANNELUP 	|Kanal hoch
|LIRC.Channel- 	|KEY_CHANNELDOWN 	|Kanal runter
|LIRC.PrevChannel 	|KEY_PREVIOUS 	|zurück zum zuvor gewählten Kanal
|LIRC.Volume+ 	|KEY_VOLUMEUP 	|Lautstärke erhöhen
|LIRC.Volume- 	|KEY_VOLUMEDOWN 	|Lautstärke verringern
|LIRC.Mute 	|KEY_MUTE 	|Stummschalten
|LIRC.Subtitles 	|KEY_SUBTITLE 	|Untertitel einblenden
|LIRC.Schedule 	|KEY_EPG 	|Programmführer
|LIRC.Channels 	|KEY_CHANNEL 	|Kanäle
|LIRC.Commands 	|KEY_FAVORITES 	|Befehlsauswahl
|LIRC.Audio 	|KEY_MODE 	|Tonspur wählen
|LIRC.Timers 	|KEY_TIME 	|gesetzte Timer
|LIRC.Recordings 	|KEY_PVR 	|Aufnahmen
|LIRC.Setup 	|KEY_SETUP 	|Setup-Menü
|LIRC.User0 	|KEY_TEXT 	|aktiviert Teletext bei installiertem teletext-plugin
|LIRC.User1 	|KEY_PROG1 	|User-Taste, z.B. für Keymakros
|LIRC.User2 	|KEY_PROG2 	|User-Taste, z.B. für Keymakros
|LIRC.User3 	|KEY_PROG3 	|User-Taste, z.B. für Keymakros
|LIRC.User4 	|KEY_PROG4 	|User-Taste, z.B. für Keymakros
|LIRC.User5 	|KEY_AUDIO 	|User-Taste, z.B. für Keymakros
|LIRC.User6 	|KEY_VIDEO 	|User-Taste, z.B. für Keymakros
|LIRC.User7 	|KEY_IMAGES |User-Taste, z.B. für Keymakros
|LIRC.User8 	|KEY_FN 	|User-Taste, z.B. für Keymakros
|LIRC.User9 	|KEY_SCREEN |User-Taste, z.B. für Keymakros
|=========================================

[[evmaps]]
===== evmaps =====

[CAUTION]
.Wann sind evmaps sinnvoll?
=====================================================================
evmaps sollten nur für Geräte angelegt werden, die keine andere Möglichkeit bieten die Tastennamen zu verändern. Für Lirc- und rc-core-Geräte sollte man vorzugsweise eine entsprechene Konfigurationsdatei (<<lirc,lircd.conf>> bzw. <<ir-keytable_keymap,Keymap>>) zur korrekten Belegung der Tasten erstellen.
=====================================================================

Alle Tastendrücke, die an Eventlirc weitergereicht werden, können durch Übersetzungstabellen, die sogenannten https://bugs.yavdr.com/projects/yavdr-remote/repository/revisions/master/show/evmaps[evmaps] footnote:[Eventmaps] noch verändert werden, bevor sie an den VDR übergeben werden. Sie befinden sich unter '/etc/eventlircd.d/' und sind entweder nach dem Gerätenamen, dem Treiber oder nach der Produkt- und Hersteller-ID aus ihrer <<udev-rules,udev-Regel>> benannt.

.Beispiel für die Syntax in einer evmap:
----
KEY_PROG1	= KEY_MENU #Ich bin ein Kommentar
----
Hier wird das Tasten-Event *KEY_PROG1* umbenannt. Der VDR empfängt dadurch das Lirc-Event *KEY_MENU*

===== Informationen über den Empfänger sammeln =====

[[cat-proc]]
.Einen ersten Überblick, ob der Empfänger erkannt wurde gibt die Auflistung der Eingabegeräte des des Systems:
----
cat /proc/bus/input/devices
----

Hier werden alle Eingabegeräte aufgelistet, für die ein Eintrag unter '/dev/input/' angelegt wird. Für USB-Lirc-Empfänger, die automatisch konfiguriert werden, oder für über das Webfrontend eingerichtete Lirc-Geräte gibt es keinen gesonderten Eintrag, sie können an der Zeile *N: Name="lircd"* erkannt werden.

Im folgenden mal Beispiele für verschiedene Eingabegeräte:

----
user@yaVDR:~$ cat /proc/bus/input/devices
----

.Power-Button am Gehäuse
----
I: Bus=0019 Vendor=0000 Product=0001 Version=0000
N: Name="Power Button"
P: Phys=PNP0C0C/button/input0
S: Sysfs=/devices/LNXSYSTM:00/device:00/PNP0C0C:00/input/input0
U: Uniq=
H: Handlers=kbd event0
B: PROP=0
B: EV=3
B: KEY=10000000000000 0

I: Bus=0019 Vendor=0000 Product=0001 Version=0000
N: Name="Power Button"
P: Phys=LNXPWRBN/button/input0
S: Sysfs=/devices/LNXSYSTM:00/LNXPWRBN:00/input/input1
U: Uniq=
H: Handlers=kbd event1
B: PROP=0
B: EV=3
B: KEY=10000000000000 0
----

.Angeschlossene Tastatur
----
I: Bus=0011 Vendor=0001 Product=0001 Version=ab41
N: Name="AT Translated Set 2 keyboard"
P: Phys=isa0060/serio0/input0
S: Sysfs=/devices/platform/i8042/serio0/input/input2
U: Uniq=
H: Handlers=sysrq kbd event2
B: PROP=0
B: EV=120013
B: KEY=402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe
B: MSC=10
B: LED=7
----

.direkt eingebundene Fernbedienung, hier Hama MCE Remote mit Tastatur- und Mausfunktion
----
I: Bus=0003 Vendor=05a4 Product=9881 Version=0110 <1>
N: Name="HID 05a4:9881"
P: Phys=usb-0000:00:02.0-2/input0
S: Sysfs=/devices/pci0000:00/0000:00:02.0/usb2/2-2/2-2:1.0/input/input3
U: Uniq=
H: Handlers=sysrq kbd event3 <2>
B: PROP=0
B: EV=120013
B: KEY=e080ffdf01cfffff fffffffffffffffe
B: MSC=10
B: LED=7

I: Bus=0003 Vendor=05a4 Product=9881 Version=0110 <1>
N: Name="HID 05a4:9881"
P: Phys=usb-0000:00:02.0-2/input1
S: Sysfs=/devices/pci0000:00/0000:00:02.0/usb2/2-2/2-2:1.1/input/input4
U: Uniq=
H: Handlers=kbd mouse0 event4 <2>
B: PROP=0
B: EV=17
B: KEY=1f0000 2020000 3878d801d001 1e000000000000 0
B: REL=103
B: MSC=10
----
<1> Die Tastenbelegung von direkt eingebundenen Eingabegeräten kann über <<evmaps, Evmaps>> angepasst werden
<2> Wollte man die direkt vom Eingabegerät ausgegebenen Tastendrücke beobachten, müsste man nach dem Stoppen von eventlircd das Tool <<evtest,evtest>> mit dem Pfad '/dev/input/event3' bzw. '/dev/input/event4' aufrufen.

.Eventlircd
----
I: Bus=0003 Vendor=05a4 Product=9881 Version=0110
N: Name="eventlircd"
P: Phys=/dev/input/event4
S: Sysfs=/devices/virtual/input/input5
U: Uniq=
H: Handlers=mouse1 event5
B: PROP=0
B: EV=7
B: KEY=10000 0 0 0 0
B: REL=3
----
Dieses Eingabegerät existiert immer, wenn eventlircd läuft. Es ist das virtuelle Eingabegerät, das alle Tastendrücke der angeschlossenen und entsprechend Konfigurierten Empfänger sammelt und an den VDR weiterleitet.

.rc-core Empfänger
----
I: Bus=0018 Vendor=0000 Product=0000 Version=0000
N: Name="i2c IR (Hauppauge WinTV PVR-350"
P: Phys=i2c-2/2-0018/ir0
S: Sysfs=/devices/virtual/rc/rc0/input6 <1>
U: Uniq=
H: Handlers=kbd event6
B: PROP=0
B: EV=100013
B: KEY=108fc010 2468d100000000 0 18000 18040002801 8e168000000000 ffe
B: MSC=10
----
<1> Existiert ein Gerät mit einem Sysfs-Pfad, der mit */devices/virtual/rc/rc* beginnt, kann es mittels <<ir-keytable, ir-keytable>> konfiguriert werden.

.Lirc-Gerät mit --uinput
----
I: Bus=0000 Vendor=0000 Product=0000 Version=0000
N: Name="lircd"
P: Phys=
S: Sysfs=/devices/virtual/input/input7
U: Uniq=
H: Handlers=sysrq rfkill kbd event7
B: PROP=0
B: EV=100003
B: KEY=ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffff fffffffffffffffe
----

[[ir-keytable]]
==== ir-keytable ====

ir-keytable gibt Auskunft über das angelegte Inputdevice('/dev/input/eventX'), das verwendete Protokoll und den verwendeten Treiber für IR-Eingabegeräte, die *rc-core* bzw. das Treibermodul *ir-core* verwenden. Außerdem ist das Programm dafür zuständig Tastenbelegungen zu laden, die nicht dem vorgegebenen Stand in den rc-core Treibern entsprechen.
[[rc-core_keys]]
[CAUTION]
.Anpassung der Tastenbelegung für rc-core Empfänger
=====================================================================
Im Gegensatz zu Empfängern, die als Tastatur erkannt werden, deren Tastenbelegung nur mittels evmaps geändert werden kann, macht es für rc-core Empfänger keinen Sinn die Tastenbelegung über evmaps zu ändern. Sinnvoller ist es eine angepasste Keytable zu <<ir-keytable_keymap,erstellen>> und diese über eine Regel in der '/etc/rc_maps.cfg' beim Start <<ir-keytable-load,automatisch laden>> zu lassen.

Falls bereits alle Tasten eine Ausgabe mit definiertem Namen liefern, hilft das http://www.vdr-portal.de/board60-linux/board14-betriebssystem/board96-yavdr/109471-hilfsskript-f%C3%BCr-rc-core-empf%C3%A4nger/[hier gepostete Skript] eine benutzerdefinierte Keytable zu erstellen und laden zu lassen, deren Tastennamen und -belegung man dann sicher vor eventuellen Updates der bei yaVDR mitgelieferten Keytables anpassen kann.
=====================================================================

[[ir-keytable-pvr350]]
.Beispiel für eine Hauppauge PVR350 mit IR-Empfänger:
----
user@yavdr:~$ sudo ir-keytable
Found /sys/class/rc/rc0/ (/dev/input/event3) with:      <1>
	Driver ir-kbd-i2c, table rc-rc5-tv              <2>
	Supported protocols: RC-5                       <3>
	Enabled protocols:                  
Repeat delay = 500 ms, repeat period = 33 ms       
----
<1> Die Fernbedienung wurde unter '/dev/input/event3' eingebunden
<2> Der verwendete Treiber ist *ir-kbd-i2c*, die von ir-core geladene Keytable heißt rc-rc5-tv. Mit diesen Informationen 
<3> Das unterstützte Protokoll ist http://de.wikipedia.org/wiki/RC-5[*RC-5*]

===== geladene Keymap(s) auslesen =====

Der folgende Befehl gibt die bereits für einen Empfänger geladene Zuordnung von Scancodes und Tastennamen aus. Das ist insbesondere dann hilfreich, wenn zwar eine Keymap geladen wurde, aber die Benennung der Tasten noch nicht <<remote.conf,*Namespace-konform*>> ist.

----
sudo ir-keytable -r
----

===== Scancodes ermitteln =====

Mit *ir-keytable* kann man auch Tastencodes der Fernbedienung ermitteln, z.B. um zu sehen ob überhaupt Tastendrücke erkannt werden oder um eine Keymap zu erstellen, die zur '/vdr/lib/vdr/remote.conf' des yaVDR passt.
Da Tastendrücke von eventlircd abgefangen werden, muss dieser Dienst <<stop-eventlircd,gestoppt sein>>. Außerdem ist es empfehlenswert den VDR vorher zu <<stop-vdr,stoppen>>, um eine unbeabsichtigte Fehlbedienung zu vermeiden.

[[pvr350-wok]]
.Beispielausgabe ohne geladene Keytable
----
user@yavdr:~$ sudo ir-keytable -t
Testing events. Please, press CTRL-C to abort.
1310546299.271540: event MSC: scancode = 3d
1310546300.071543: event MSC: scancode = 3b
1310546301.471538: event MSC: scancode = 01
1310546301.871547: event MSC: scancode = 02
1310546302.271537: event MSC: scancode = 03
----

[[ir-keytable_keymap]]
===== Keymap erstellen =====

Passend zur eigenen Fernbedienung kann man sich nun eine Keymap erstellen, dabei muss der scancode in eine Hexadezimalzahl übertragen und der Taste eine Funktion zugewiesen werden.
Aus *scancode = 3d* wird also *0x003d*, aus *scancode = 01* wird *0x0001* usw.

Die Keymap wird dann am besten unter einem möglichst aussagekräftigen Namen unter '/etc/rc_keymaps/' gespeichert, wo sie keine Gefahr läuft von mit yaVDR-Updates ausgelieferten Keytables überschrieben zu werden. Die von yaVDR mitgelieferten Keytables liegen unter '/lib/udev/rc_keymaps/' und können als Vorlage für angepasste Keytables verwendet werden.

.Beispiel für eine selbst definierte Keytable, die unter '/etc/rc_keymaps/pvr350' gespeichert würde (Auszug)
----
# table rc-rc5-tv, type: RC-5 <1>
0x003b KEY_SETUP
0x003d KEY_POWER2
0x0001 KEY_1
0x0002 KEY_2
0x0003 KEY_3
[...]
----
<1> Die erste Zeile der Keytable sollte den Namen der Keytable sowie den verwendeten Protokoll-Typ (hier RC-5) enthalten.

[CAUTION]
.Kommentare in den Keymaps
=====================================================================
ir-keytable akzeptiert keine reinen Kommentarzeilen. Wird eine Kopfzeile verwendet, die Keytable-Name und Fernbedienungsprotokoll angibt, so muss darauf geachtet werden, dass für beide Parameter erlaubte Werte eingetragen sind.

.*Falsch* wäre also:
----
# table rc-rc5-tv, type  <1>
# Ich bin ein Kommentar  <2>
0x003b KEY_SETUP
0x003d KEY_POWER2
0x0001 KEY_1
0x0002 KEY_2
0x0003 KEY_3
[...]
----
<1> Kein Protokolltyp angegeben
<2> reine Kommentarzeilen sind nicht erlaubt

.*Korrekt* geht es so:
----
# table rc-rc5-tv, type: RC-5 <1>
0x003b KEY_SETUP # Ich bin ein Kommentar <2>
0x003d KEY_POWER2
0x0001 KEY_1
0x0002 KEY_2
0x0003 KEY_3
----
<1> Vollständige Angabe des Namens der Keytable und des verwendeten Protokolls
<2> Kommentare hinter der Tastendefinition sind erlaubt

=====================================================================

[[ir-keytable-load]]
===== Keymap laden =====

Damit die Keytable auch automatisch geladen wird, muss eine Regel in '/etc/rc_maps.cfg' für die Fernbedienung erstellt werden. Da die Datei <<template,getemplated>> ist, sollte man ein entsprechendes Custom-Template für die eigene Einträge erstellen, um ein Überschreiben der Regel durch Updates von yaVDR zu vermeiden.

.'/etc/rc_maps.cfg'
----
# driver          table                           file
<1> ir-kbd-i2c      rc-rc5-tv                       /etc/rc_keymaps/pvr350
----
<1> Den Treiber und den Namen der Keytable haben wir wie weiter oben beschrieben mittels <<ir-keytable-pvr350,*sudo ir-keytable*>> ermittelt.

Zu Testzwecken kann man Einstellungen für per ir-core eingebundene Geräte auch von Hand laden oder zurücksetzen. 

[NOTE]
.Wie wird die rc_maps.cfg ausgewertet?
=====================================================================
Dazu wird eine udev-Regel in /lib/udev/rules.d/40-ir-keytable.rules benutzt, die gemäß den Regeln in der /etc/rc_maps.cfg die dort eingestellten Keymaps lädt (ir-keytable -a /etc/rc_maps.cfg).
=====================================================================

.Manuelles Laden einer Keymap durch ir-keytable
----
user@yavdr:~$ sudo ir-keytable -c <1> -p rc-5 <2> -w /etc/rc_keymaps/pvr350 <3>
----
<1> *-c* entfernt alle bereits geladenen Keymaps
<2> *-p <Protokoll>* setzt das IR-Protokoll
<3> *-w <keymap>* gibt die zu ladende Keymap an.
Weitere  Informationen findet man in der <<manpages,Manpage>> von *ir-keytable*.

[[pvr350-wk]]
.Beispielausgabe von *ir-keytable -t* für die <<pvr350-wok,gleichen Tasten>> mit passender Keytable
----
user@yavdr:~$ sudo ir-keytable -t
Testing events. Please, press CTRL-C to abort.
1310546400.571539: event MSC: scancode = 3d
1310546400.571545: event key down: KEY_POWER2 (0x0164)
1310546400.571547: event sync
1310546400.820703: event key up: KEY_POWER2 (0x0164)
1310546400.820705: event sync
1310546401.471543: event MSC: scancode = 3b
1310546401.471551: event key down: KEY_SETUP (0x008d)
1310546401.471553: event sync
1310546401.720700: event key up: KEY_SETUP (0x008d)
1310546401.720703: event sync
1310546406.271547: event MSC: scancode = 01
1310546406.271556: event key down: KEY_1 (0x0002)
1310546406.271558: event sync
1310546406.520700: event key up: KEY_1 (0x0002)
1310546406.520703: event sync
1310546407.071539: event MSC: scancode = 02
1310546407.071543: event key down: KEY_2 (0x0003)
1310546407.071545: event sync
1310546407.320705: event key up: KEY_2 (0x0003)
1310546407.320709: event sync
1310546407.871539: event MSC: scancode = 03
1310546407.871544: event key down: KEY_3 (0x0004)
1310546407.871546: event sync
1310546408.120700: event key up: KEY_3 (0x0004)
1310546408.120702: event sync
----


[[evtest]]
==== evtest ====

*evtest* ist ein Programm, das es erlaubt nähere Informationen über ein unter '/dev/input/event<X>' eingebundenes Gerät zu erhalten. Es kann über das Paket *evtest* nachinstalliert werden. Um eine Ausgabe von Tastendrücken sehen zu können, muss man <<stop-eventlircd,eventlircd zuvor stoppen>>.

----
user@yavdr:~$ sudo evtest /dev/input/event3
Input driver version is 1.0.1
Input device ID: bus 0x18 vendor 0x0 product 0x0 version 0x0    <1>
Input device name: "i2c IR (Hauppauge WinTV PVR-350"            <2>
Supported events:
  Event type 0 (Sync)
  Event type 1 (Key)                                            
    Event code 1 (Esc)                                          <3>
    Event code 2 (1)
    Event code 3 (2)
    Event code 4 (3)
    Event code 5 (4)
    Event code 6 (5)
    Event code 7 (6)
    Event code 8 (7)
    Event code 9 (8)
    Event code 10 (9)
    Event code 11 (0)
    Event code 103 (Up)
    Event code 105 (Left)
    Event code 106 (Right)
    Event code 108 (Down)
    Event code 113 (Mute)
    Event code 114 (VolumeDown)
    Event code 115 (VolumeUp)
    Event code 119 (Pause)
    Event code 128 (Stop)
    Event code 139 (Menu)
    Event code 141 (Setup)
    Event code 158 (Back)
    Event code 167 (Record)
    Event code 168 (Rewind)
    Event code 207 (Play)
    Event code 208 (Fast Forward)
    Event code 352 (Ok)
    Event code 356 (Power2)
    Event code 358 (Info)
    Event code 359 (Time)
    Event code 363 (Channel)
    Event code 365 (EPG)
    Event code 366 (PVR)
    Event code 370 (Subtitle)
    Event code 373 (Mode)
    Event code 388 (Text)
    Event code 398 (Red)
    Event code 399 (Green)
    Event code 400 (Yellow)
    Event code 401 (Blue)
    Event code 402 (ChannelUp)
    Event code 403 (ChannelDown)
    Event code 407 (Next)
    Event code 412 (Previous)
  Event type 4 (Misc)
    Event code 4 (ScanCode)
  Event type 20 (Repeat)
Testing ... (interrupt to exit)
----
<1> Produkt- und Hersteller-ID
<2> Produktname, z.B. für eine udev-Regel
<3> Ab hier sind die verfügbaren Tasten der Fernbedienung aufgelistet

[[udev]]
==== udev ====

http://wiki.ubuntuusers.de/udev[udev] ist ein Dienst, der es erlaubt Hardware dynamisch zu erkennen und in das System einzubinden. Für jedes Gerät, das vom Hersteller i.d.R. mit individuellen Identifikationsmerkmalen ausgestattet wurde, kann so anhand von <<udev-rules,udev-Regeln>> festgelegt werden, welche Treiber, Module oder Befehle aktiviert werden sollen, sobald ein Gerät erkannt wird.

[[udev-rules]]
===== udev-Regeln =====

Über Regeln in der Datei https://github.com/yavdr/yavdr-remote/blob/master/udev/98-eventlircd.rules['/lib/udev/rules.d/98-eventlircd.rules'] kann festgelegt werden, welche Konfiguration eventlircd für angeschlossene USB-Fernbedienungen lädt.

.Beispiel für einen Eintrag in '/lib/udev/rules.d/98-eventlircd.rules'
----
ENV{ID_VENDOR_ID}=="0419", ENV{ID_MODEL_ID}=="0001", \                      <1>
  ENV{eventlircd_enable}="true",\                                           <2>
  ENV{eventlircd_evmap}="03_$env{ID_VENDOR_ID}_$env{ID_MODEL_ID}.evmap"     <3>
----
<1> Die Fernbedienung wird anhand der ID_VENDOR_ID und der ID_MODEL_ID erkannt (siehe <<evtest,evtest>>)
<2> Erlaubt eventlircd die Eingaben des Geräts zu verwerten
<3> Lädt die <<evmaps,evmap>> für das Gerät. In diesem Fall entsteht nach Einsetzen der Umgebungsvariablen der Name "03_0419_0001.evmap", demnach wird '/etc/eventlircd.d/03_0419_0001.evmap' als Keymap geladen.


[CAUTION]
.Sonderfälle
=====================================================================
In einigen Fällen kann mittels Vendor-ID und Model-ID nicht zuverlässig zwischen bestimmten Empfängern unterschieden werden (z.B. X10-Empfänger).
Hier werden weitere udev-Attribute ausgewertet. Die für diese Empfänger angepassten udev-Regeln sind unter '/lib/udev/rules.d/98-eventlircd-names.conf' zu finden.
=====================================================================

[[udev-tools]]
===== udev-Crashkurs =====

.TODO:
****
* näheres zu UDEV, mitgelieferte und benutzerdefinierte Regeln, UDEV-Merkmale ermitteln <<
****

.TODO
****
* udev für USB-FB
****

Weitere Informationen über ein Eingabegerät kann man mittels udevadm herausfinden. Es eignet sich gut, wenn man Kriterien für <<udev-rules,udev-Regeln>> bestimmen möchte:

[[udevadm]]
.udevadm
----
user@yavdr:~$ sudo udevadm info --query=all --attribute-walk --name=/dev/input/event4

Udevadm info starts with the device specified by the devpath and then
walks up the chain of parent devices. It prints for every device
found, all possible attributes in the udev rules key format.
A rule to match, can be composed by the attributes of the device
and the attributes from one single parent device.

  looking at device '/devices/virtual/input/input4/event4':
    KERNEL=="event4"
    SUBSYSTEM=="input"
    DRIVER==""

  looking at parent device '/devices/virtual/input/input4':
    KERNELS=="input4"
    SUBSYSTEMS=="input"
    DRIVERS==""
    ATTRS{name}=="Sundtek Ltd. Remote Control"
    ATTRS{phys}==""
    ATTRS{uniq}==""
    ATTRS{modalias}=="input:b0003v0000p0000e0001-e0,1,2,4,14,k71,72,73,74,80,9E,A7,AE,CF,161,174,18E,18F,190,191,192,193,ramlsfw"
----

[[irw]]
==== irw ====

Wenn eventlircd <<status-remoted,gestartet>> ist, zeigt der Befehl *sudo irw* die an den VDR gesendeten Tastendrücke an. Die Ausgabe der erkannten Tastendrücke kann per *STRG + c* <<control-c,abgebrochen>> werden.
*irw* kann auch auf den Sockets von lircd lauschen, wenn man ihm den Pfad zu diesem als Argument übergibt.

.irw bei eventlircd mit einer Hama MCE Remote
----
user@yavdr:~$ sudo irw
<1> <2>  <3>       <4>
67 0 KEY_UP   devinput
6c 0 KEY_DOWN devinput
----
<1> Tastencode
<2> Tastendruck 0=Event
<3> Name der Taste
<4> Die Tasten werden per devinput an eventlirc übergeben

.irw für lircd am Beispiel eines Atric-Empfängers footnote:[http://www.atric.de/IR-Einschalter/index.php] mit Hauppauge A415-HPG-WE Fernbedienung
----
# PID von lircd bestimmen
user@yavdr:~$ sudo pidof lircd
765
user@yavdr:~$ sudo irw /var/run/lirc/lircd.765
<1>               <2>  <3>      <4>
0000000000001794 00 KEY_UP hvr4000-2
0000000000001794 01 KEY_UP hvr4000-2
0000000000001795 00 KEY_UP hvr4000-2
0000000000001795 01 KEY_UP hvr4000-2

# Falls man sicher ist, dass nur eine lircd-Instanz läuft geht auch dieser Befehl:
sudo irw /var/run/lirc/lircd.$(pidof lircd)
----
<1> Tastencode
<2> 00=Taste gedrückt 01=Taste losgelassen
<3> Name der Taste
<4> Benutzte Fernbedienung aus der lircd.conf für die Tastenzuordnung

[[lircd2uinput]]
==== lircd2uinput ====

lircd2uinput ist eine Bridge, die die Tastendrücke von einem Lirc-Socket über ein virtuelles HID-Gerät weiterreichen kann. Dieses kann dann z.B. über eine udev-Regel von eventlircd eingebunden und genutzt werden. Unter {version} wird dies für alle Lirc-Empfänger und den irserver genutzt. Auch andere Dienste, die über einen Lirc-Socket Tastendrücke liefern können so eingebunden werden.

In der Voreinstellung reicht lircd2uinput jeden vom Lirc-Socket gelieferten Tastendruck durch. Falls es zum Prellen (z.B. doppelte Tastendrücke bei einfachem Tastendruck) von Fernbedienungstasten kommt oder die Fernbedienung zu schnell reagiert, kann man einen Repeat-Filter einsetzen. Dieser lässt sich im Webfrontend einfach auf der Seite zur Fernbedienung aktivieren und über die Konfigurationsdatei in /etc/yavdr/lircd2uinput.conf feinjustieren. Es stehen folgende Parameter zur Verfügung:

----
$ lircd2uinput -h
Usage: lircd2uinput [options]

Options:
  -h, --help            show this help message and exit
  -f, --repeat-filter   enable repeat-filter
  -s LIRCD_SOCKET, --lircd-socket=LIRCD_SOCKET
                        choose lircd socket to listen on
  -d, --debug           enable debug mode
  -x, --xbmc            enable xbmc single keypress mode
  -l MIN_GAP, --min-gap=MIN_GAP
                        set minimum gap between repeated keystrokes (default
                        150000 µs) - needs active repeat-filter
  -u MAX_GAP, --max-gap=MAX_GAP
                        set maximum gap between repeated keystrokes (default
                        300000 µs) - needs active repeat-filter
  -r WAIT_REPEATS, --min-repeats=WAIT_REPEATS
                        number of repeats before using accelerated keypresses
                        (default = 2) - needs active repeat-filter
  -t TIMEOUT, --timeout=TIMEOUT
                        release key after x ms no following key is received
                        (default = 200 ms)
  -a ACCELERATION, --acceleration=ACCELERATION
                        acceleration to get from MAX_GAP to MIN_GAP. default
                        value of 0.25 equals 4 repeated keystrokes to reach
                        maximum speed - needs active repeat-filter
----


==== IR-Server ====
Einige Origen-Gehäuse binden ihre Fernbedienung über den IR-Server ein. Die Konfigurationsdateien für die Fernbedienungen liegen unter '/usr/share/irtrans/remote/'. Damit sie unter {version} funktionieren, müssen die Tastennamen *Namespace-konform* sein. vom Lirc-Socket, den IR-Server bereitstellt werden die empfangenen Tastendrücke dann über lircd2uinput an eventlircd weitergereicht.

[[lirc]]
==== LIRC Empfänger ====

////
.TODO:
****
* lircd.conf, hardware.conf
* Beispielhardware lirc_ttusbir, lirc_parallel, lircd interne userspace treiber usw.

Chat-Auszug:

[qanda]
Ich: Und was wären Beispiele für weitere Geräte neben Seriellen Empfängern, die über Lircd laufen?::
steffenbpunkt: lirc_ttusbir
lirc_parallel
lircd interne userspace treiber
noch ein paar andere [...]
Ich: Ok, danke - dann werde ich die noch als Beispiele aufnehmen. Zur Konfigurationshilfe (mangels passender Hardware kann ich da leider nicht alles ausprobieren): Wenn der Nutzer noch nicht weiß wie sein Empfänger eingebunden ist, wird er aber höchstens lirc_ttusbir unter den automatisch geladenen Modulen finden und lirc_serial und lirc_parallel muss er von Hand oder über das Webfrontend in der lircd-Konfiguration einstellen.::
steffenbpunkt: genau, der Name des lirc Gerätes is in eventlircd fest eingebunden, devinput wurde wohl in Anlehnung an die lircd.conf des devinput Modus von lircd gewählt. Das es nur einen Namen gibt ist zumindest für XBMC sinnvoll, da XBMC diesen Namen auswertet.
****
////

{version} unterstützt auch Lirc-Empfänger. Je nachdem ob sie sich eindeutig identifizieren lassen werden sie entweder über eine udev-Regel footnote:[vordefinierte Regeln liegen unter /lib/udev/98-lircd.rules, die über den lircd_helper (siehe '/lib/udev/lircd_helper') lircd mit den entsprechenden Parametern starten lässt] oder das <<wfe-remote,Webfrontend>> konfiguriert.

Für Lirc-Empfänger, die über das Webfrontend konfiguriert werden, muss i.d.R. die /etc/lirc/lircd.conf von Hand mit dem gewünschten Definitionen der Fernbedienungstasten befüllt werden. Die ist entweder über das WFE möglich (<<wfe-edit_config,"Konfiguration bearbeiten">>) oder kann per SSH oder ein lokales Terminal erfolgen.


[[lirc_serial]]
===== Serielle Empfänger =====

Serielle Empfänger wie z.B. der Atric-Einschalter oder Homebrew-Empfänger lassen sich leider schlecht automatisch vorkonfigurieren, da sie mit beliebigen Fernbedienungen benutzt werden können. Trotzdem lassen sie sich in yaVDR mit wenig Aufwand zusammen mit <<lirc,LIRC>> einrichten.

.Einstellungen im Webfrontend
Im Abschnitt <<wfe-remote,Fernbedienung>> des yaVDR-Webfrontend setzt man das Häkchen bei Lirc-Unterstützung und wählt den geeigneten Empfänger aus der Liste.
Für Atric-Einschalter ist dies der Eintrag "*Home-brew (16x50 UART compatible serial port)*". Außerdem muss noch die Serielle Schnittstelle angegeben werden, über die der Empfänger angeschlossen ist. Die Nummerierung orientiert sich normalerweise an den Angaben im Handbuch des Mainboards.

.Anpassen der lircd.conf
Im nächsten Schritt muss dann noch eine passende lircd.conf nach '/etc/lirc/lircd.conf' kopiert werden. Die dort verwendeten Tastennamen müssen <<namespace-faq, *Namespace-konform* zur input.h des Kernels>> sein und sollten sich (wenn sie zur Steuerung des VDR und XBMC genutzt werden sollen) an der <<remote.conf, remote.conf>> orientieren, da die Fernbedienung dann sowohl mit dem VDR als auch unter XBMC ohne weitere Konfiguration verwendet werden kann.

.Beispiel alte lircd.conf zu neuer lircd.conf

.yaVDR 0.3 bzw. "alte" lircd.conf
----
[...]
begin codes
          Up                   0x1794
          Down                 0x1795
          Ok                   0x17A5
          left                 0x1796
          right                0x1797
          info                 0x179B
[...]
----

.{version}
----
[...]
begin codes
          KEY_UP                   0x1794
          KEY_DOWN                 0x1795
          KEY_OK                   0x17A5
          KEY_LEFT                 0x1796
          KEY_RIGHT                0x1797
          KEY_INFO                 0x179B
[...]
----

Nach einem <<restart-eventlircd,Neustart von eventlircd>> kann man die für den seriellen Empfänger konfigurierte Fernbedienung benutzen.
Die Tasten-Ausgabe von lircd kann unter '/var/run/lirc/lircd.<PID>' mittels irw ausgelesen werden.

[[lirc_igor]]
===== Igor USB =====

Für die Igor USB-Empfänger muss lediglich eine passende <<namespace, Namespace-konforme>> lircd.conf nach /etc/lirc/ kopiert werden. Über eine udev-Regel wird automatisch ein passender lircd-Prozess gestartet und dessen Ausgabe von eventlircd ausgewertet. Der Socket von lircd liegt typischerweise unter '/var/run/lirc/lircd-lirc0' und kann mittels <<irw, irw>> auf Funktion überprüft werden.

[CAUTION]
.Cave Einstellungen zur Fernbedienung im Webfrontend!
=====================================================================
Bei Igor USB-Empfängern darf Lirc nicht für den Igor über das Webfrontend aktiviert und eingerichtet werden, da sonst zwei lircd-Prozesse gestartet werden, die sich gegenseitig blockieren und die Funktion der Fernbedienung verhindern!
=====================================================================

[[lirc_yausbir]]
===== yaUsbIr =====

Der yaUsbIr-Empfänger footnote:[siehe http://www.vdr-portal.de/board18-vdr-hardware/board13-fernbedienungen/111753-yausbir-lirc-f%C3%A4higer-usb-ir-empf%C3%A4nger-sender-mit-einschalter/?s=fe5464cec7949ed10dfae76056ae1404df47e899] ist ein IR-Empfänger und Einschalter, der über USB angeschlossen wird. Damit stellt er eine interessante Alternative zu den bislang nur mit Serieller Schnittstelle verfügbaren Atric IR-Einschaltern dar. Vermutlich aufgrund eines Bugs in der libusb (es treten unter Ubuntu falsche "remove" Events auf) kann er nicht über udev-Regeln eingerichtet werden, sondern muss im yaVDR-Webfrontend von Hand aktiviert werden.

[[lirc_atric_usb]]
===== Atric IR-WakeupUSB =====

Die Grundkonfiguration für den Atric IR-WakeupUSB Empfänger kann über das Webfrontend vorgenommen werden (Eintrag *Atric IR-WakeupUSB*). Der Empfänger ist durch eine Udev-Regel immer unter dem Symlink /dev/irman erreichbar.

Zum Anlernen einer Fernbedienung (nachdem das Protokoll mit Hilfe des Konfigurationsprogrammes festgelegt wurde) führt man diese Befehle aus und folgt den Anweisungen von irrecord. Die gewählten Tastennamen sollten dabei dem yaVDR-<<namespace, Namespace>> entsprechen:
----
$ cd /etc/lirc/
$ sudo stop lircd
$ sudo irrecord -H irman -d /dev/irman lircd.conf
----

Nach dem Anlernen kann man lircd wie gewohnt starten:
----
sudo start lircd
----

[[usb_irmp]]
==== IRMP Empfänger ====

Die USB-IRMP-Empfänger benötigen das Paket *yavdr-addon-irmp*. Bei der Installation werden alle nötigen Programme wie irmplircd und ir_control mitinstalliert. Wird das Gerät anhand seine Attribute ATTRS\{idVendor\}=="16c0", ATTRS\{idProduct\}=="27d9" über udev erkannt, wird der Upstart-Job /etc/init/irmplircd gestartet.

Damit die empfangenen Tastendrücke von <<lircd2uinput,lircd2uinput>> an <<evenlircd,eventlircd>> weitergegeben werden können, muss in der '/etc/default/irmplircd' noch der Pfad für eine passende Keymap als Wert für Variable *KEYMAP* angegeben werden (für weitere Informationen zur Konfiguration siehe '/usr/share/doc/irmplircd/README.Debian').

Die nötige Zuordnung erhält man durch das Auslesen der Scancodes mittels irw vom Sockel von irmplircd:

----
$ sudo irw /var/run/irmplircd
<1>            <2> <3>           <4>
0250af00f200 0 0250af00f200 IRMP
0250af00b600 0 0250af00b600 IRMP
[...]

----
<1> Scancode
<2> n-te Wiederholung
<3> gemappter Tastencode (momentan kein Mapping vorhanden)
<4> Name

Daraus lässt sich dann eine Keymap erstellen, die z.B. so aussieht:

----
<1>            <2>
0250af00f200 KEY_UP
0254ab002c00 KEY_RIGHT
[...]
----
<1> Scancode
<2> Tastenname

Die verwendeten Tastennamen müssen <<namespace-faq, *Namespace-konform* zur input.h des Kernels>> sein und sollten sich (wenn sie zur Steuerung des VDR und XBMC genutzt werden sollen) an der <<remote.conf, remote.conf>> orientieren, da die Fernbedienung dann sowohl mit dem VDR als auch unter XBMC ohne weitere Konfiguration verwendet werden kann.

[[X10]]
==== X10-Fernbedienungen ====
Mit dem neuen Kernel 3.2.x in {version} werden die X10-Empfänger über rc-core eingebunden.

[CAUTION]
.Änderung durch linux-media-dkms bzw. Kernel 3.2.x
=====================================================================
Durch die im Kernel enthaltenen Treiber werden die X10-Empfänger nicht mehr als tastaturartige Eingabegeräte erkannt, sondern durch ein neues Treibermodul (das ebenfalls den Namen *ati_remote* trägt) als <<ir-keytable,rc-core Gerät>> eingebunden. Dementsprechend sollte die <<rc-core_keys,Anpassung der Tastennamen>> dann über eigene Keytables erfolgen.
=====================================================================

[NOTE]
.X10-Fernbedienungen mit Scrollrad
=====================================================================
Das standardmäßig von {version} genutzte Treibermodul ati_remote unter dem Kernel 3.2 untestützt das Scrollrad bestimmter X10-Fernbedienungen noch nicht. Im Paket *media-build-experimental-dkms* sind aktualisierte Treiber enthalten, die die Unterstützung für das Scrollrad nachrüsten. Alternativ kann über den Ubuntu LTS Enablement Stack ein Kernel >= 3.5 installiert werden. footnote:[siehe http://wiki.ubuntuusers.de/Kernel#Backport-Kernel]
=====================================================================

[[bluetooth]]
==== Bluetooth-Geräte ====

Prinzipiell ist es unter yaVDR möglich auch Bluetooth-Geräte, die als Eingabegerät erkannt werden zur Steuerung zu nutzen. Dabei sollte man sich überlegen ob man das Gerät nur als Tastatur bzw. Maus oder als Fernbedienung für VDR und XBMC nutzen will - letzteres erfoldert etwas Bastelarbeit mit udev-Regeln, damit die Geräte an eventlircd gebunden werden.

[[bt-pairing]]
===== Pairing =====

Damit ein Bluetooth-Gerät mit dem Rechner kommunizieren kann, muss es erst Authentifiziert werden. Um sich nicht von Verwaltungsprogrammen mit GUI abhängig zu machen, verwenden wir die Tools aus dem Paket *bluez-utils*, das ggf. noch nachinstalliert werden muss.

.Anzeigen der Bluetooth-Adapter - liefert das hci<X> Gerät
-----
hciconfig
-----

.Suche nach Geräten (diese müssen sichtbar sein, für die PS3 Remote BD muss "Start" + "Enter" gleichzeitig gedrückt werden)
-----
sudo bluez-test-discovery
-----

Hier muss man sich nun das gewünschte Gerät heraussuchen und den Wert für "Address" notieren.

.Für Geräte mit Display, die eine PIN-Eingabe beim Pairen erfordern, kann man nun so eine Authentifizierung vornehmen:
-----
sudo bluez-simple-agent hci<X> <adresse>
-----

.Für Geräte wie die PS3 Remote oder andere Bluetooth-Fernbedienungen und Tastaturen ohne default-Pin:
-----
sudo bluez-test-device create <adresse>
sudo bluez-test-device trusted <adresse> yes
-----

.Verbindung zum Testen aufbauen:
----
sudo bluez-test-input connect <adresse>
----

Die "PS3 Remote BD" kann nach dem einmaligen Pairen direkt genutzt werden. Ihre Tasten werden über die '/etc/eventlircd.d/ps3remote.evmap' konfiguriert.








